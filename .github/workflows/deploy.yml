name: MiniFlow CI/CD Pipeline
on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      rollback:
        description: 'Enable rollback mode'
        type: boolean
        default: false
env:
  PYTHON_VERSION: "3.11"
jobs:
  test:
    name: ğŸ§ª Test Suite
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-xdist pytest-timeout

      - name: Run tests with SQLite
        env:
          APP_ENV: test
          DB_TYPE: sqlite
          DATABASE_URL: sqlite:///./test_miniflow.db
          CONFIG_PATH: ./configurations/test.ini
        run: |
          pytest tests/ \
            -v \
            -n auto \
            --timeout=300 \
            --cov=src \
            --cov-report=xml \
            --cov-report=html \
            --cov-fail-under=75 \
            --junitxml=junit.xml

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.xml
          flags: unittests
          fail_ci_if_error: false

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            coverage.xml
            htmlcov/
            junit.xml
          retention-days: 30

  deploy-production:
    name: ğŸš€ Deploy to Production
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && !inputs.rollback)
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://miniflow.vidinsight.com.tr  
    concurrency:
      group: production-deployment
      cancel-in-progress: false
    
    steps:
      - name: Blue-Green Deployment
        uses: appleboy/ssh-action@v1.0.3
        env:
          VERSION: ${{ needs.code-quality.outputs.version }}
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: ${{ secrets.PROD_PORT || 22 }}
          envs: VERSION,GITHUB_REPO,GITHUB_TOKEN
          command_timeout: 30m
          script: |
            set -euo pipefail
            
            echo "ğŸš€ MiniFlow Production Deployment v${VERSION}"
            echo "ğŸŒ Domain: https://miniflow.vidinsight.com.tr  "
            echo "ğŸ‘¤ User: ubuntu (primary user)"
            
            # Configuration - Ubuntu kullanÄ±cÄ±sÄ±na gÃ¶re ayarlÄ±
            APP_NAME="miniflow"
            DEPLOY_USER="ubuntu"
            DEPLOY_ROOT="/opt/miniflow"
            BLUE_DIR="${DEPLOY_ROOT}/blue"
            GREEN_DIR="${DEPLOY_ROOT}/green"
            SHARED_DIR="${DEPLOY_ROOT}/shared"
            CURRENT_LINK="${DEPLOY_ROOT}/current"
            DOMAIN="miniflow.vidinsight.com.tr"
            
            # Create directory structure with ubuntu ownership
            sudo mkdir -p "${BLUE_DIR}" "${GREEN_DIR}" "${SHARED_DIR}"/{data,logs,backups,ssl}
            sudo chown -R ${DEPLOY_USER}:${DEPLOY_USER} "${DEPLOY_ROOT}"
            
            # Determine current and target environments
            if [ -L "${CURRENT_LINK}" ]; then
              CURRENT_ENV=$(basename "$(readlink -f "${CURRENT_LINK}")")
              if [ "${CURRENT_ENV}" = "blue" ]; then
                TARGET_ENV="green"
                TARGET_DIR="${GREEN_DIR}"
                TARGET_PORT=9002
              else
                TARGET_ENV="blue"
                TARGET_DIR="${BLUE_DIR}"
                TARGET_PORT=9001
              fi
            else
              CURRENT_ENV=""
              TARGET_ENV="blue"
                TARGET_DIR="${BLUE_DIR}"
                TARGET_PORT=9001
            fi
            
            echo "ğŸ“Š Deployment: ${CURRENT_ENV:-none} â†’ ${TARGET_ENV} (Port: ${TARGET_PORT})"
            
            # Backup SQLite database
            if [ -f "${SHARED_DIR}/data/miniflow.db" ]; then
              echo "ğŸ’¾ Backing up database..."
              BACKUP_FILE="${SHARED_DIR}/backups/miniflow_$(date +%Y%m%d-%H%M%S).db"
              cp "${SHARED_DIR}/data/miniflow.db" "${BACKUP_FILE}"
              chmod 600 "${BACKUP_FILE}"
              echo "âœ… Backup saved: ${BACKUP_FILE}"
            fi
            
            # Clean target directory
            rm -rf "${TARGET_DIR}"
            mkdir -p "${TARGET_DIR}"
            
            # Clone repository
            echo "ğŸ“¥ Cloning repository..."
            git clone --depth 1 --branch main \
              https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git \
              "${TARGET_DIR}"
            
            cd "${TARGET_DIR}"
            
            # Create virtual environment
            echo "ğŸ Creating virtual environment..."
            python3.11 -m venv venv
            source venv/bin/activate
            
            # Install dependencies
            echo "ğŸ“¦ Installing dependencies..."
            pip install --upgrade pip setuptools wheel
            pip install -r requirements.txt
            pip install gunicorn
            
            # Create environment file
            echo "ğŸ“ Creating environment file..."
            cat > .env << EOF
            APP_ENV=production
            DB_TYPE=sqlite
            DATABASE_URL=sqlite:///${SHARED_DIR}/data/miniflow.db
            CONFIG_PATH=./configurations/prod.ini
            JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
            SECRET_KEY=${{ secrets.SECRET_KEY }}
            SERVER_HOST=0.0.0.0
            SERVER_PORT=${TARGET_PORT}
            LOG_LEVEL=${{ secrets.LOG_LEVEL || 'WARNING' }}
            DOMAIN=${DOMAIN}
            EOF
            
            # Create production config
            mkdir -p configurations
            cat > configurations/prod.ini << EOF
            [app]
            name = MiniFlow
            environment = production
            debug = false
            
            [server]
            host = 0.0.0.0
            port = ${TARGET_PORT}
            workers = 8
            
            [database]
            type = sqlite
            path = ${SHARED_DIR}/data/miniflow.db
            
            [logging]
            level = WARNING
            file = ${SHARED_DIR}/logs/app.log
            max_bytes = 104857600
            backup_count = 10
            EOF
            
            # Run database setup/migrations
            echo "ğŸ—„ï¸ Setting up database..."
            python -m src.miniflow setup
            python -m src.miniflow migrate || echo "No migrations needed"
            
            # Create systemd service for target (ubuntu user)
            echo "âš™ï¸ Creating systemd service..."
            sudo tee /etc/systemd/system/${APP_NAME}-${TARGET_ENV}.service > /dev/null << SERVICEEOF
            [Unit]
            Description=MiniFlow Production ${TARGET_ENV} v${VERSION}
            After=network.target
            
            [Service]
            Type=simple
            User=${DEPLOY_USER}
            Group=${DEPLOY_USER}
            WorkingDirectory=${TARGET_DIR}
            Environment="PATH=${TARGET_DIR}/venv/bin"
            EnvironmentFile=${TARGET_DIR}/.env
            ExecStart=${TARGET_DIR}/venv/bin/gunicorn \
              -w 4 \
              -b 0.0.0.0:${TARGET_PORT} \
              --timeout 120 \
              --access-logfile ${SHARED_DIR}/logs/access.log \
              --error-logfile ${SHARED_DIR}/logs/error.log \
              --capture-output \
              --enable-stdio-inheritance \
              "src.miniflow:create_app()"
            
            Restart=always
            RestartSec=10
            StandardOutput=append:${SHARED_DIR}/logs/systemd.log
            StandardError=append:${SHARED_DIR}/logs/error.log
            
            # Security Hardening
            NoNewPrivileges=true
            PrivateTmp=true
            ProtectSystem=strict
            ProtectHome=true
            ReadWritePaths=${SHARED_DIR}
            
            [Install]
            WantedBy=multi-user.target
            SERVICEEOF
            
            # Reload and start target service
            sudo systemctl daemon-reload
            sudo systemctl enable ${APP_NAME}-${TARGET_ENV}
            
            echo "â–¶ï¸ Starting ${TARGET_ENV} service..."
            sudo systemctl restart ${APP_NAME}-${TARGET_ENV}
            
            # Wait for service to initialize
            sleep 5
            
            # Health check with retries
            echo "ğŸ¥ Health checking ${TARGET_ENV}..."
            for i in {1..60}; do
              if curl -f -s http://localhost:${TARGET_PORT}/health > /dev/null 2>&1; then
                echo "âœ… ${TARGET_ENV} is healthy!"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "âŒ Health check failed on ${TARGET_ENV}!"
                echo "ğŸ“‹ Service status:"
                sudo systemctl status ${APP_NAME}-${TARGET_ENV} --no-pager
                echo ""
                echo "ğŸ“ Recent logs:"
                sudo journalctl -u ${APP_NAME}-${TARGET_ENV} -n 20 --no-pager
                sudo systemctl stop ${APP_NAME}-${TARGET_ENV}
                exit 1
              fi
              if [ $((i % 10)) -eq 0 ]; then
                echo "â³ Attempt $i/60... (checking logs)"
                sudo journalctl -u ${APP_NAME}-${TARGET_ENV} -n 5 --no-pager
              else
                echo "â³ Attempt $i/60..."
              fi
              sleep 3
            done
            
            # Setup SSL with Certbot if not exists
            if [ ! -f "${SHARED_DIR}/ssl/fullchain.pem" ]; then
              echo "ğŸ”’ Setting up SSL certificate..."
              sudo apt-get update -qq
              sudo apt-get install -y -qq certbot python3-certbot-nginx
              
              # Request certificate
              echo "ğŸ“œ Obtaining SSL certificate..."
              sudo certbot certonly --nginx \
                -d ${DOMAIN} \
                --non-interactive \
                --agree-tos \
                --email ${{ secrets.SSL_EMAIL || 'admin@vidinsight.com.tr' }} \
                --cert-name miniflow
            
              # Copy certs to shared directory
              if [ -d "/etc/letsencrypt/live/miniflow" ]; then
                sudo cp /etc/letsencrypt/live/miniflow/fullchain.pem ${SHARED_DIR}/ssl/
                sudo cp /etc/letsencrypt/live/miniflow/privkey.pem ${SHARED_DIR}/ssl/
                sudo chown ${DEPLOY_USER}:${DEPLOY_USER} ${SHARED_DIR}/ssl/*
                echo "âœ… SSL certificates copied to shared directory"
              else
                echo "âŒ SSL certificate directory not found!"
                exit 1
              fi
              
              # Setup auto-renewal cron job
              echo "0 0 * * 0 root certbot renew --quiet && cp /etc/letsencrypt/live/miniflow/* ${SHARED_DIR}/ssl/ && systemctl reload nginx" | sudo tee /etc/cron.d/certbot-renewal > /dev/null
              sudo chmod 644 /etc/cron.d/certbot-renewal
            fi
            
            # Generate Nginx configuration with current port
            echo "ğŸ”§ Configuring Nginx..."
            sudo tee /etc/nginx/sites-available/${APP_NAME} > /dev/null << NGINXEOF
            upstream miniflow_backend {
                server localhost:${TARGET_PORT} max_fails=3 fail_timeout=30s;
                keepalive 32;
            }
            
            # HTTP â†’ HTTPS redirect
            server {
                listen 80;
                listen [::]:80;
                server_name ${DOMAIN} www.${DOMAIN};
                
                location /.well-known/acme-challenge/ {
                    root /var/www/certbot;
                }
                
                location / {
                    return 301 https://\$host\$request_uri;
                }
            }
            
            # HTTPS server
            server {
                listen 443 ssl http2;
                listen [::]:443 ssl http2;
                server_name ${DOMAIN} www.${DOMAIN};
                
                # SSL Configuration
                ssl_certificate ${SHARED_DIR}/ssl/fullchain.pem;
                ssl_certificate_key ${SHARED_DIR}/ssl/privkey.pem;
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers HIGH:!aNULL:!MD5;
                ssl_prefer_server_ciphers on;
                ssl_session_cache shared:SSL:10m;
                ssl_session_timeout 10m;
                
                # Security Headers
                add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
                add_header X-Frame-Options "SAMEORIGIN" always;
                add_header X-Content-Type-Options "nosniff" always;
                add_header X-XSS-Protection "1; mode=block" always;
                
                client_max_body_size 100M;
                client_body_timeout 120s;
                
                # Proxy settings
                location / {
                    proxy_pass http://miniflow_backend;
                    proxy_http_version 1.1;
                    
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_set_header Connection "";
                    
                    proxy_connect_timeout 60s;
                    proxy_send_timeout 60s;
                    proxy_read_timeout 60s;
                    
                    proxy_buffering on;
                    proxy_buffer_size 4k;
                    proxy_buffers 8 4k;
                }
                
                # Health check endpoint
                location /health {
                    proxy_pass http://miniflow_backend/health;
                    access_log off;
                }
                
                # Static files
                location /static {
                    alias ${SHARED_DIR}/static;
                    expires 30d;
                    add_header Cache-Control "public, immutable";
                }
                
                # Favicon
                location = /favicon.ico {
                    log_not_found off;
                    access_log off;
                }
            }
            NGINXEOF
            
            # Enable site and reload Nginx
            sudo ln -sf /etc/nginx/sites-available/${APP_NAME} /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
            
            echo "ğŸ§ª Testing Nginx configuration..."
            sudo nginx -t
            
            echo "ğŸ”„ Reloading Nginx..."
            sudo systemctl reload nginx
            
            # Final production health check via HTTPS
            echo "ğŸ¥ Final health check via HTTPS..."
            sleep 5
            
            # Check HTTP redirect
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://${DOMAIN}/health)
            if [ "$HTTP_CODE" != "301" ] && [ "$HTTP_CODE" != "302" ]; then
              echo "âš ï¸ Warning: HTTP redirect not working (got ${HTTP_CODE})"
            else
              echo "âœ… HTTP â†’ HTTPS redirect working"
            fi
            
            # Check HTTPS
            if ! curl -f -k https://localhost/health > /dev/null 2>&1; then
              echo "âŒ HTTPS health check failed!"
              exit 1
            else
              echo "âœ… HTTPS health check passed"
            fi
            
            # Update current symlink atomically
            ln -sfn "${TARGET_DIR}" "${CURRENT_LINK}.new"
            mv -Tf "${CURRENT_LINK}.new" "${CURRENT_LINK}"
            echo "âœ… Switched to ${TARGET_ENV} environment"
            
            # Gracefully stop old environment
            if [ -n "${CURRENT_ENV}" ]; then
              echo "ğŸ›‘ Stopping old ${CURRENT_ENV} environment..."
              sudo systemctl stop ${APP_NAME}-${CURRENT_ENV} || true
              sudo systemctl disable ${APP_NAME}-${CURRENT_ENV} || true
            fi
            
            # Cleanup old backups (keep last 30 days)
            echo "ğŸ§¹ Cleaning old backups..."
            find "${SHARED_DIR}/backups" -name "*.db" -mtime +30 -delete 2>/dev/null || true
            
            echo ""
            echo "âœ… Production deployment v${VERSION} completed successfully!"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸŒ URL: https://miniflow.vidinsight.com.tr/health "
            echo "ğŸ“¦ Version: ${VERSION}"
            echo "ğŸ¯ Active Environment: ${TARGET_ENV}"
            echo "ğŸ”Œ Port: ${TARGET_PORT}"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Show final service status
            echo ""
            echo "ğŸ“Š Service Status:"
            sudo systemctl status ${APP_NAME}-${TARGET_ENV} --no-pager

      - name: Test deployment
        run: |
          echo "ğŸ§ª Testing deployment..."
          sleep 10
          
          # Test HTTPS health endpoint
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://miniflow.vidinsight.com.tr/health )
          if [ "$RESPONSE" = "200" ]; then
            echo "âœ… HTTPS health check passed!"
          else
            echo "âŒ HTTPS health check failed! (HTTP ${RESPONSE})"
            exit 1
          fi
          
          # Test HTTP redirect
          REDIRECT=$(curl -s -o /dev/null -w "%{http_code}" http://miniflow.vidinsight.com.tr/health )
          if [ "$REDIRECT" = "301" ] || [ "$REDIRECT" = "302" ]; then
            echo "âœ… HTTP â†’ HTTPS redirect working!"
          else
            echo "âš ï¸ Warning: HTTP redirect returned ${REDIRECT}"
          fi

      - name: Create GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: MiniFlow ${{ needs.code-quality.outputs.version }}
          body: |
            ## ğŸš€ MiniFlow Release ${{ needs.code-quality.outputs.version }}
            
            ### âœ¨ Deployed to Production
            - ğŸŒ URL: https://miniflow.vidinsight.com.tr/ 
            - ğŸ“¦ Version: ${{ needs.code-quality.outputs.version }}
            - ğŸ”’ SSL: Enabled (Let's Encrypt)
            - ğŸ’¾ Database: SQLite
            - ğŸ¯ Strategy: Blue-Green Deployment
            - ğŸ“ Commit: ${{ github.sha }}
            - ğŸ‘¤ Author: ${{ github.actor }}
            
            ### ğŸ”„ Deployment Details
            - Zero downtime deployment
            - Automatic database backup
            - Health checks passed
            - SSL certificate active
            - User: ubuntu
          draft: false
          prerelease: false

  rollback:
    name: ğŸ”„ Emergency Rollback
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && inputs.rollback
    environment:
      name: production
    
    steps:
      - name: Execute rollback
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: ${{ secrets.PROD_PORT || 22 }}
          script: |
            set -euo pipefail
            
            echo "ğŸš¨ EMERGENCY ROLLBACK INITIATED"
            echo "ğŸŒ Domain: https://miniflow.vidinsight.com.tr "
            echo "ğŸ‘¤ User: ubuntu"
            
            APP_NAME="miniflow"
            DEPLOY_ROOT="/opt/miniflow"
            CURRENT_LINK="${DEPLOY_ROOT}/current"
            SHARED_DIR="${DEPLOY_ROOT}/shared"
            DOMAIN="miniflow.vidinsight.com.tr"
            
            if [ ! -L "${CURRENT_LINK}" ]; then
              echo "âŒ No active deployment found!"
              exit 1
            fi
            
            CURRENT_ENV=$(basename "$(readlink -f "${CURRENT_LINK}")")
            
            if [ "${CURRENT_ENV}" = "blue" ]; then
              ROLLBACK_ENV="green"
              ROLLBACK_PORT=9002
            else
              ROLLBACK_ENV="blue"
              ROLLBACK_PORT=9001
            fi
            
            ROLLBACK_DIR="${DEPLOY_ROOT}/${ROLLBACK_ENV}"
            
            if [ ! -d "${ROLLBACK_DIR}" ]; then
              echo "âŒ No previous version found for rollback!"
              exit 1
            fi
            
            echo "â†©ï¸  Rolling back from ${CURRENT_ENV} to ${ROLLBACK_ENV}"
            
            # Restore last database backup
            LATEST_BACKUP=$(ls -t "${SHARED_DIR}/backups"/*.db 2>/dev/null | head -n 1)
            if [ -n "${LATEST_BACKUP}" ]; then
              echo "ğŸ’¾ Restoring database backup..."
              cp "${LATEST_BACKUP}" "${SHARED_DIR}/data/miniflow.db"
              chmod 600 "${SHARED_DIR}/data/miniflow.db"
              echo "âœ… Database restored from: ${LATEST_BACKUP}"
            fi
            
            # Start rollback service
            echo "â–¶ï¸ Starting ${ROLLBACK_ENV} service..."
            sudo systemctl start ${APP_NAME}-${ROLLBACK_ENV}
            
            # Health check
            for i in {1..30}; do
              if curl -f http://localhost:${ROLLBACK_PORT}/health > /dev/null 2>&1; then
                echo "âœ… ${ROLLBACK_ENV} is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ Rollback environment failed to start!"
                sudo systemctl status ${APP_NAME}-${ROLLBACK_ENV}
                exit 1
              fi
              sleep 3
            done
            
            # Update Nginx
            echo "ğŸ”„ Switching Nginx to ${ROLLBACK_ENV}..."
            sudo sed -i "s|localhost:[0-9]*|localhost:${ROLLBACK_PORT}|g" /etc/nginx/sites-available/${APP_NAME}
            sudo nginx -t && sudo systemctl reload nginx
            
            # Final check
            sleep 3
            if ! curl -f -k https://localhost/health > /dev/null 2>&1; then
              echo "âŒ HTTPS health check failed after rollback!"
              exit 1
            fi
            
            # Update symlink
            ln -sfn "${ROLLBACK_DIR}" "${CURRENT_LINK}"
            
            # Stop current environment
            echo "ğŸ›‘ Stopping ${CURRENT_ENV}..."
            sudo systemctl stop ${APP_NAME}-${CURRENT_ENV}
            
            echo ""
            echo "âœ… Rollback to ${ROLLBACK_ENV} completed successfully!"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸŒ URL: https://miniflow.vidinsight.com.tr "
            echo "ğŸ¯ Active Environment: ${ROLLBACK_ENV}"
            echo "ğŸ”Œ Port: ${ROLLBACK_PORT}"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"





